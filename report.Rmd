---
title: "AMR Country Hotspots"
output:
  rmdformats::html_clean:
    lightbox: TRUE
    gallery: TRUE
    thumbnails: FALSE
    keep_md: TRUE
---
```{r setup, include = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width=20)
library(tidyverse)
library(httr)
library(brms)
library(bayesplot)
library(here)
library(ggthemes)
library(rnaturalearth)
library(rnaturalearthdata)
library(countrycode)
library(sf)
library(leaflet)
library(leaflet.extras)

h <- here::here
source(h("R/functions.R"))

color_scheme_set("viridis") # for diagnostics

# data - raw and imputed
amr_mice <- read_rds(h("model/mice-imputation.rds")) 

amr_with_imputes <- amr_mice %>% 
  mice::complete(.) %>% 
  select(-ab_import_perc) %>%
  mutate(country = countrycode::countrycode(sourcevar = iso3c,
                                            origin = "iso3c",
                                            destination = "country.name")  )
amr_raw <- amr_mice$data %>%
  select(-iso3c) %>%
  gather(key ="var", value = "x") %>%
  drop_na()

# model results
fit_combined <- read_rds(h("model/fit_combined.rds"))
fit_all <- read_rds( h("model/fit_all.rds"))
me_combined <- read_rds(h("model/fit_combined_marginal_effects.rds"))
me_all <- read_rds(h("model/fit_all_marginal_effects.rds"))

# event data
url_events <- "https://raw.githubusercontent.com/ecohealthalliance/amr-db/master/data/events_db.csv"
events <- GET(url_events, authenticate("emmamendelsohn", Sys.getenv("GITHUB_PAT")))
events <- read_csv(content(events, "text")) 

url_locs <- "https://raw.githubusercontent.com/ecohealthalliance/amr-db/master/data/locations.csv"
locs <- GET(url_locs, authenticate("emmamendelsohn", Sys.getenv("GITHUB_PAT")))
locs <- read_csv(content(locs, "text")) %>%
  filter(study_id %in% events$study_id) %>%
  filter(!is.na(study_location)) 

# get posterior samples of data
beta_samples <- posterior_samples(fit_combined, subset = sample(nsamples(fit_combined), 500, replace = F)) 

# get zi vars
zi_vars <- beta_samples %>%
  select(matches("zi_"), -b_zi_Intercept) %>%
  colnames(.) %>%
  gsub("^b_zi_", "", .)

# get pois vars
pois_vars <- beta_samples %>%
  select(-matches("zi_"), -b_Intercept, -lp__) %>%
  colnames(.)%>%
  gsub("^b_", "", .)

# zi_vars <- c("ln_promed_mentions_per_capita", "ln_pubs_sum_per_capita", "ln_gdp_per_capita", "ln_population", "english_spoken")
# pois_vars <- c("ln_livestock_consumption_kg_per_capita", "ln_migrant_pop_perc", "ln_tourism_inbound_perc",  "ln_tourism_outbound_perc", "ab_export_perc", "health_expend_perc", "human_consumption_ddd", "english_spoken", "ln_pubs_sum_per_capita", "ln_promed_mentions_per_capita", "ln_gdp_per_capita")

lookup_vars <- c( "health_expend_perc" ="Health Expenditure (% GDP)", 
                  "ln_migrant_pop_perc" = "Migrant Population (% Pop.; ln scale)",  
                  "ln_population" = "Population (ln scale)",
                  "english_spoken" = "English Spoken", 
                  "human_consumption_ddd" = "Human AB Consumption (DDD)", 
                  "ln_livestock_consumption_kg_per_capita" = "Livestock AB Consumption (per capita; ln scale)",
                  # "ln_livestock_consumption_kg_per_pcu" = "Livestock AB Consumption (per PCU; ln scale)",
                  # "ln_livestock_pcu" = "Livestock Population (PCU; ln scale)", 
                  "ab_export_perc" = "AB Exports (% GDP)", 
                  "ln_gdp_per_capita" = "GDP (per capita; ln scale)", 
                  "ln_tourism_outbound_perc" = "Tourism - Outbound (% Pop; ln scale)", 
                  "ln_tourism_inbound_perc"  = "Tourism - Inbound (% Pop; ln scale)",
                  "ln_pubs_sum_per_capita" = "Publication Bias Index (per capita; ln scale)",
                  "ln_promed_mentions_per_capita" = "ProMed Mentions (per capita; ln scale)")

global_labeller <- labeller(
  var = lookup_vars
)
```

```{r sum}
summary(fit_combined)
```

```{r diagnostics}
# Trace Plots
stanplot(fit_combined, type = "trace")

y <- amr_with_imputes$n_amr_events
yrep <- posterior_predict(fit_combined, nsamples = 1000) 
yord <- order(y)
yrep <- yrep[,yord]
y <- y[yord]

ppc_dens_overlay(y, yrep) + scale_x_continuous(limits = c(0, 50)) + labs(title = "Density Overlay")

ppc_hist(y, yrep)

prop_zero <- function(x) mean(x == 0)
ppc_stat(y, yrep, stat = "prop_zero", binwidth = 0.005) + labs(title = "Proportion Zeros")

int_dat <- ppc_intervals_data(y, yrep) 
int_dat <- int_dat %>%
  filter(y_obs>0) %>%
  mutate(in_50 = y_obs >= l & y_obs <= h,
         in_90 = y_obs >= ll & y_obs <= hh)

p50 <- round(100*sum(int_dat$in_50)/nrow(int_dat))
p90 <- round(100*sum(int_dat$in_90)/nrow(int_dat))

ppc_intervals(y, yrep) + labs(title = "Observations versus Predictions (individual observations)", caption = paste0("dark line = 50% probability\nfaded line = 90% probability\n", p50, "% non-zeros in 50% prob\n", p90,  "% non-zeros in 90% prob"))

y_grped <- tibble(y) %>%
  mutate(grp = cut(y, breaks = c(0,  1, 10, 20, 50, Inf), right = FALSE)) %>%
  group_by(grp) %>%
  mutate(n = n()) %>%
  ungroup() %>%
  mutate(grp = paste0(grp, " (n = ", n, ")")) %>%
  dplyr::select(-n)

y_grped_sum <- y_grped %>%
  group_by(grp) %>%
  summarize(med = median(y)) %>%
  mutate(ytype = "y")

colnames(yrep) <- y_grped$grp

yrep_grped <- map_df(unique(colnames(yrep)), function(x){
  
  grp <- yrep[, x]
  med <- median(grp)
  prob_50_upper <- quantile(grp, 0.75)
  prob_50_lower <- quantile(grp, 0.25)
  prob_90_upper <- quantile(grp, 0.95)
  prob_90_lower <- quantile(grp, 0.05)
  
  tibble(grp = x, med, prob_50_upper, prob_50_lower, prob_90_upper, prob_90_lower, ytype = "yrep")
  
})

yall <- bind_rows(y_grped_sum, yrep_grped)

ggplot(data = yall, aes(x = grp)) + 
  geom_errorbar(aes(ymin = prob_50_lower, ymax = prob_50_upper), color = color_scheme_get()[2], width=0, size = 1.5) +
  geom_errorbar(aes(ymin = prob_90_lower, ymax = prob_90_upper), color = color_scheme_get()[2], width=0, alpha = 0.3, size = 1.5) +
  geom_point(aes(x = grp, y = med, color = ytype, fill = ytype), pch=21, size = 3) +
  scale_fill_manual(values = c("y" = unname(color_scheme_get()[6]), "yrep" = unname(color_scheme_get()[1]))) +
  scale_color_manual(values = c("y" = unname(color_scheme_get()[5]), "yrep" = unname(color_scheme_get()[2]))) +
  labs(title = "Observations versus Predictions(grouped by intervals)", caption = "dark line = 50% probability; faded line = 90% probability; points are medians", x = "", y = "", color = "", fill = "")

```

```{r partial-effects}
# Partial effects - each model over data range
# Y = Marginal effects for continuous variables measure the instantaneous rate of change - they provide a
# good approximation to the amount of change in Y that will be produced by a 1-unit change in Xk.

me_all2 <- imap_dfr(me_all, function(x, y){
  get_me_dat(x) %>%
    mutate(iteration = y) 
})

me_all2_avg <- me_all2 %>%
  group_by(value, var) %>%
  summarize(mean = mean(estimate__)) %>%
  ungroup() 

ggplot(me_all2, aes(x = value)) + 
  geom_line(aes(y = estimate__, group = iteration), color = "cornflowerblue", size=.5, alpha = 0.4) +
  geom_line(data = me_all2_avg, aes(x = value, y = mean)) +
  facet_wrap(~var,  labeller = global_labeller, scales = "free") +
  labs(x = "", y = "Additive Change in AMR Emergence Event Count", title = "", caption = "Blue lines represent individual model iterations; black line is average model") +
  theme_minimal() 

ggsave(filename = h("plots/marginal_effects_multi.png"), width = 22, height = 12)

# Get Zi partial effects
out_zi <- map_dfr(zi_vars, function(var){
  
  minx <- amr_with_imputes %>% pull(var) %>% min(., na.rm = T)
  maxx <- amr_with_imputes %>% pull(var) %>% max(., na.rm = T)
  seqx <- seq(from = minx, to = maxx, length.out = 100)
  
  betas <- as.matrix(beta_samples[,grep("zi", colnames(beta_samples))])
  
  X <- matrix(
    c(1, colMeans(as.matrix(amr_with_imputes[,zi_vars]))),
    nrow = length(zi_vars) + 1, ncol = length(seqx),
  )
  rownames(X) <- c("Intercept", zi_vars)
  
  assertthat::assert_that(all(rownames(X) ==  gsub("^b_zi_", "", colnames(betas))))
  
  X[var, ] <- seqx
  Y <- plogis(betas %*% X)
  out <- as_tibble(Y) %>% 
    mutate(samp = 1:nrow(Y)) %>% 
    gather("x", "y", -samp) %>% 
    mutate(x = rep(seqx, each = nrow(betas)),
           var = var)
  
  return(out)
})

# reverse axis
out_zi <- out_zi %>% mutate(y = 1-y)

# summarize
out_zi_sum <- out_zi %>% 
  group_by(x, var) %>% 
  summarise(med = median(y),
            lo = quantile(y, .025),
            hi = quantile(y, .975)) %>%
  ungroup()

labs <- out_zi_sum %>% 
  group_by(var) %>% 
  summarize(x = quantile(x, 0.5)) %>%
  mutate(y = 0.9)

p_zi_lines <- 
  ggplot() + 
  geom_line(data = out_zi, aes(x = x, y = y, group = samp), color = "gray60", alpha = 0.1) + #For lots of lines
  geom_line(data = out_zi_sum, aes(x = x, y = med), color = "black") +
  geom_rug(data = filter(amr_raw, var %in% zi_vars), mapping = aes(x = x)) + 
  # geom_text(data = labs, aes(x = x, y = y, label = var)) +
  facet_wrap(var ~ ., scales = "free_x", drop = FALSE,  ncol = 2, labeller = global_labeller) +
  labs(y = "Logisitic Prob. of Non-zero Outcome\n", x = "", main = "") +
  theme_few() +
  theme(strip.text.x = element_text(size = 14), 
        axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))


ggsave(plot = p_zi_lines, 
       filename = h("plots/zi_marginal_effects.png"), width = 12.5, height = 12)

# Get Pois partial effects
out_pois <- map_dfr(pois_vars, function(var){
  
  minx <- amr_with_imputes %>% pull(var) %>% min(., na.rm = T)
  maxx <- amr_with_imputes %>% pull(var) %>% max(., na.rm = T)
  seqx <- seq(from = minx, to = maxx, length.out = 100)
  
  betas <- cbind(as.matrix(beta_samples[,c(grep("b_[^z]", colnames(beta_samples)))]), 1)
  colnames(betas)[ncol(betas)] <- "offset"
  
  X <- matrix(
    c(1, colMeans(as.matrix(amr_with_imputes[,c(pois_vars, "ln_population")]))),
    nrow = length(pois_vars) + 2, ncol = length(seqx),
  )
  rownames(X) <- c("Intercept", pois_vars, "offset") 
  
  assertthat::assert_that(all(rownames(X) ==  gsub("^b_", "", colnames(betas))))
  
  X[var, ] <- seqx
  Y <- exp(betas %*% X)
  out <- as_tibble(Y) %>% 
    mutate(samp = 1:nrow(Y)) %>% 
    gather("x", "y", -samp) %>% 
    mutate(x = rep(seqx, each = nrow(betas)),
           var = var)
  
  return(out)
})

out_pois_sum <- out_pois %>% 
  group_by(x, var) %>% 
  summarise(med = median(y),
            lo = quantile(y, .025),
            hi = quantile(y, .975))

p_pois_lines <-  
  ggplot() + 
  geom_line(data = out_pois, aes(x = x, y = y, group = samp), color = "gray60", alpha = 0.1) + #For lots of lines
  geom_line(data = out_pois_sum, aes(x = x, y = med), color = "black") +
  geom_rug(data = filter(amr_raw, var %in% pois_vars), mapping = aes(x = x, y = 0)) + 
  facet_wrap(var ~ ., scales = "free", drop = FALSE,  nrow = 3, labeller = global_labeller) +
  labs(y = "AMR Emergence Event Count\n", x = "", main = "Poisson Model (zi)") +
  theme_few() +
  theme(strip.text.x = element_text(size = 14), 
        axis.title = element_text(size = 14),
        axis.text = element_text(size = 14))

ggsave(plot = p_pois_lines,
       filename = h("plots/pois_marginal_effects.png"), width = 25, height = 12)
```

```{r country-predictions}
amr_predict <- amr_with_imputes %>%
  mutate(mod_predict = predict(fit_combined)[,1]) %>%
  select(iso3c, mod_predict, n_amr_events)

# matrix of beta samples
betas <- cbind(as.matrix(beta_samples[,c(grep("b_[^z]", colnames(beta_samples)))]), 1)
colnames(betas)[ncol(betas)] <- "b_ln_population"

# matrix of data by country
X <- cbind("Intercept" = 1 , amr_with_imputes[,c(pois_vars, "ln_population")]) %>%
  as.matrix(.) %>%
  t()
colnames(X) <- amr_with_imputes$iso3c
X2 <- X
X2["ln_population",] <- 0 # set population to zero to calculate rate

# calc poisson predictions for each country for each beta sample
assertthat::assert_that(all(rownames(X) ==  gsub("^b_", "", colnames(betas))))
Y <- exp(betas %*% X)
Y2 <- exp(betas %*% X2)

# post process
pois_predicts <- as_tibble(Y) %>% 
  mutate(samp = 1:nrow(Y)) %>% 
  gather("iso3c", "pois_predict", -samp) %>%
  mutate(v = "mean_pop")

Y2 <- as_tibble(Y2) %>% 
  mutate(samp = 1:nrow(Y2)) %>% 
  gather("iso3c", "pois_predict", -samp) %>%
  mutate(v = "zero_pop")

pois_predicts <- bind_rows(pois_predicts, Y2) %>%
  group_by(iso3c, v) %>%
  summarise(med = median(pois_predict),
            lo = quantile(pois_predict, .025),
            hi = quantile(pois_predict, .975)) %>%
  ungroup() %>%
  left_join(amr_predict) %>% # would need full model equation for distributions of predictions 
  mutate(continent = countrycode(sourcevar = iso3c,
                                 origin = "iso3c",
                                 destination = "continent"),
         country = countrycode(sourcevar = iso3c,
                               origin = "iso3c",
                               destination = "country.name"))

# plot poisson predictions for countries with 0 events
zero_predicts <- pois_predicts %>%
  filter(n_amr_events==0, v == "mean_pop") %>%
  mutate(country= fct_reorder(country, med)) %>%
  ggplot(., aes(y = med, x= country)) +
  geom_errorbar(aes(ymin = lo, ymax = hi), color = "#FF2700",  width=0) +
  geom_point(color = "#FF2700") + 
  geom_point(aes(y = mod_predict), color = "#008FD5") +
  facet_grid(continent ~ ., scales = "free") + 
  labs(x="", y="AMR Events") +
  coord_flip() +
  theme_bw()

zero_predicts
ggsave(plot = zero_predicts, filename = h("plots/zero_predictions.png"), width = 12, height = 22)

# plot poisson predictions for countries with 0 events - per population
zero_predicts_cor <- pois_predicts %>%
  filter(n_amr_events==0, v == "zero_pop") %>%
  mutate(country= fct_reorder(country, med)) %>%
  ggplot(., aes(y = med, x= country)) +
  geom_errorbar(aes(ymin = lo, ymax = hi), color = "#FF2700",  width=0) +
  geom_point(color = "#FF2700") + 
  facet_grid(continent ~ ., scales = "free") + 
  labs(x="", y="AMR Events") +
  coord_flip() +
  theme_bw()

zero_predicts_cor
ggsave(plot = zero_predicts_cor, filename = h("plots/zero_predictions_pop_corrected.png"), width = 12, height = 22)

# get contribution of each variable to country total
beta_means <- apply(betas, 2, mean) 
Y_cont <- beta_means * X
pois_cont <- as_tibble(Y_cont) %>% 
  mutate(var = rownames(Y_cont)) %>%
  gather(key = "iso3c", value = "value", -var) %>%
  mutate(country = countrycode(sourcevar = iso3c,
                               origin = "iso3c",
                               destination = "country.name"))
# plot contributions for non-zero countries
nonzeros <- amr_with_imputes %>% filter(n_amr_events>0) %>% pull(country)
variable_cont <- pois_cont %>%
  filter(country %in% nonzeros, var != "Intercept") %>%
  ggplot(data = ., aes(x = country, y = value, fill = var)) + 
  geom_bar(stat = "identity") +
  coord_flip()+
  labs(x= "", y = "", fill = "") +
  theme_bw() + 
  #scale_fill_economist() +
  theme(legend.position = "top")
variable_cont
ggsave(plot = variable_cont, filename = h("plots/variable_contributions.png"), width = 12, height = 22)


```

```{r map}
# map pois predicts 
admin <- ne_countries(type='countries', scale = 'large') %>%
  st_as_sf() %>%
  mutate(iso3c = countrycode(sourcevar = name,
                             origin = "country.name",
                             destination = "iso3c"),
         iso3c = ifelse(is.na(iso3c), iso_a3_eh, iso3c)) %>%
  select(name, iso3c)

admin <- left_join(admin, pois_predicts, by = "iso3c") %>%
  mutate(med = ifelse(v=="mean_pop", round(med, 0), med*10000)) %>%
  select(name, iso3c, v, "Reported AMR Events" = n_amr_events, "Predicted AMR Events" = med) 

admin_mean <- admin %>%
  filter(v == "mean_pop")

pal1 <- colorNumeric("OrRd", domain = c(admin_mean$`Predicted AMR Events`, admin_mean$`Reported AMR Events`), na.color = "#e9e9f0")

caption <- glue::glue(nrow(events), " AMR emergence events<br/>",
                      n_distinct(events$study_country), " countries<br/>",
                      n_distinct(events$drug_preferred_label), " antimicrobial drugs<br/>",
                      n_distinct(events$bacteria_preferred_label), " resistant bacteria<br/>",
                      str_sub(min(events$start_date), 1, 4), " - ",  str_sub(max(events$start_date), 1, 4))


lf1 <- leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addFullscreenControl(position = "topright") %>%
  addPolygons(data = admin_mean, 
              stroke = TRUE, color = "#46464a", weight = 1,
              fill = TRUE, fillColor = ~pal1(`Predicted AMR Events`), fillOpacity = 0.9,
              label = ~paste0(name, ": ", `Predicted AMR Events`), group = "Predicted") %>%
  addPolygons(data = admin_mean, 
              stroke = TRUE, color = "#46464a", weight = 1,
              fill = TRUE, fillColor = ~pal1(`Reported AMR Events`), fillOpacity = 0.9,
              label = ~paste0(name, ": ", `Reported AMR Events`), group = "Reported") %>%
  addCircleMarkers(data = locs,  radius = 3,
                   lng = ~jitter(lon_study), lat = ~jitter(lat_study), 
                   stroke = TRUE, color = "#210106", opacity = 1, weight = 1,
                   fill = TRUE, fillColor = "#210106", fillOpacity = 0.5,
                   label = ~study_location, group = "Reported") %>%
  addLegend(data = admin_mean, pal = pal1, values = ~`Predicted AMR Events`, position = "bottomright", title = "AMR Emergence Events") %>% 
  addControl(caption) %>%
  addLayersControl(baseGroups = c("Reported", "Predicted"), options = layersControlOptions(collapsed = FALSE), position = "bottomleft")  

lf1


htmlwidgets::saveWidget(lf1, h("plots/map_predictions.html"))

```

